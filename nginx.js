/* eslint-disable no-sync, no-process-env */
import { docker } from './docker';
import { promises as fs } from 'fs';
import path from 'path';

const UPSTREAM_DIR = '/etc/nginx/vhost.d';
const UPSTREAM_COMMENT = '# generated by nginx-proxy-swarm-upstream';
const NGINX_PROXY_CONTAINER = process.env.NGINX_PROXY_CONTAINER;

export const CONFIG_IDENTIFIER = '# GENERATED BY NGINX_PROXY_SWARM_UPSTREAM';

export function generateConfig (hosts, endpoints, port) {
  const servers = endpoints.map(endpoint => `server ${endpoint}:${port};`).join('\n');
  const config = `
  ${CONFIG_IDENTIFIER}
  ${UPSTREAM_COMMENT}
  ${servers}
  ip_hash;
  `;

  const promises = hosts.map(host => {
    const filePath = `${UPSTREAM_DIR}/${host}_upstream`;

    return fs.writeFile(filePath, config);
  });

  return Promise.all(promises);
}

export function removeConfigs (hosts) {
  hosts.forEach(host => {
    const filePath = `${UPSTREAM_DIR}/${host}_upstream`;

    fs.unlinkSync(filePath);
  });
}

export function reloadNginx () {
  console.log('Reloading nginx');

  docker.getContainer(NGINX_PROXY_CONTAINER).exec({
    Cmd: [ 'sh', '-c', '/app/docker-entrypoint.sh /usr/local/bin/docker-gen /app/nginx.tmpl /etc/nginx/conf.d/default.conf; /usr/sbin/nginx -s reload' ],
    AttachStdin: false,
    AttachStdout: true
  }, (err, exec) => {
    if (err) {
      console.log(err);

      return;
    }

    exec.start({
      hijack: true,
      stdin: false
    }, (_err, stream) => {
      if (_err) {
        console.log(_err);
      }

      docker.modem.demuxStream(stream, process.stdout, process.stderr);
    });
  });
}

export function findExistingConfigs () {
  return new Promise((resolve, reject) => {
    fs.readdir(UPSTREAM_DIR, { withFileTypes: true }, (err, files) => {
      if (err) {
        return reject(err);
      }

      const generatedFiles = files.filter(file => file.isFile()).
        filter(({ name }) => {
          const content = fs.readFileSync(path.resolve(UPSTREAM_DIR, name)).toString();

          return content.startsWith(UPSTREAM_COMMENT);
        }).
        map(({ name }) => name.split('_upstream').slice(0, -1).
          join(''));

      resolve(generatedFiles);
    });
  });
}
